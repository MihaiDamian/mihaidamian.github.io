<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Code Sushi]]></title>
  <link href="http://www.codesushi.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://www.codesushi.net/"/>
  <updated>2014-03-28T23:52:17+02:00</updated>
  <id>http://www.codesushi.net/</id>
  <author>
    <name><![CDATA[Mihai Damian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using UIViews as OpenGL Textures for Custom View Controller Transitions]]></title>
    <link href="http://www.codesushi.net/blog/2013/05/uiview-as-opengl-texture/"/>
    <updated>2013-05-01T00:00:00+03:00</updated>
    <id>http://www.codesushi.net/blog/2013/05/uiview-as-opengl-texture</id>
    <content type="html"><![CDATA[In [a previous post](/blog/2013/02/physics-uikit-2/) I've demonstrated how UIKit can be used with a physics engine. For this post I'm going to continue on the topic of mixing UIKit with technologies from the field of game development and show how UIViews can be used as textures in OpenGL.

As a practical example I've put together a sample app that simulates a <em>UINavigationController</em> where view controller transitions are animated using a cube instead of the standard slide animations. Go ahead and download the complete <a title="source code" href="https://github.com/MihaiDamian/Cube-transition-example" target="_blank">source code</a>. You can see it in action in the video below:

<div class="embed-video-container"><iframe src="http://www.youtube.com/embed/ZOpnpLiykE4 "></iframe></div>

Before we go any further I feel a disclaimer about the choice to use OpenGL in this example is needed. I have to admit it is entirely possible to construct simple 3D animations like this one using nothing but Core Animation - which being a higher level technology is easier to use. In fact <em>CATransition</em> already implements an undocumented "cube" animation identical with what I've built here from scratch. The only purpose of this example is to present the steps and challenges you need to go through in order to transform UIViews into OpenGL textures.
<h3>Drawing the view to an image</h3>
The function that makes this entire exercise possible is <em>CALayer</em>'s <em>renderInContext:</em> method. As the name suggests, this will draw a <em>CALayer</em> into a <em>CGContext</em>. By drawing into a <em>CGBitmapContext</em> (which is a subtype of <em>CGContext</em>). We can then grab the image data and pass it to OpenGL using the <em>glTexImage2D</em> function. One point to remember here is that neither Core Graphics nor OpenGL know anything about points - they only work in pixels. So whenever we transfer UIKit sizes and positions into Core Graphics or OpenGL we always need to take into account the content scale factor.

You'll find the code implementing all this in the <em>TextureAtlas</em> class. Notice the code there actually draws two views in a single texture. The input views will be the views of the view controllers involved in the transition. The reason why we render the views side by side in the same texture is that shaders (in our case thinly wrapped by <em>GLKBaseEffect</em>) normally draw a single texture in a draw call. In our case this trick simplifies the code a bit, but when rendering more complex scenes it also helps to improve performance if you manage to group up your drawing needs into fewer draw calls. This is because sending data to the graphics pipeline is usually the performance bottleneck and not the rendering itself which runs on optimized hardware.

Second think I want to point out here is the commented code I left in <em>TextureAtlas</em>. If you uncomment it you will see the texture saved as an image file in the application's Documents folder. If you open up the file you will see it's flipped on the y-axis. The happens because by default <em>CGContext</em>'s coordinate system defines the origin point to be in the lower-left corner. That may come as some surprise if you used <em>CGContext</em> in other places like in <em>UIView'</em>s <em>drawRect:</em> where the y-axis is actually flipped for your convenience to match the coordinate system of UIKit. But as OpenGL uses the same coordinate system as Core Graphics, no extra handling is needed in our case.
<h3>The right time to rasterize the views</h3>
Let's take a look at the structure of the sample app. The root view controller is <em>NavigationController</em>, a custom view controller container that mimics the native <em>UINavigationController</em>. We have <em>AnimationViewController</em>, a wrapper for the transition animation that takes two views as parameters to kick off the animation. Also there are two dummy view controllers: <em>FirstViewController</em> and <em>SecondViewController</em>.

<em>NavigationController</em> is initialized with an instance of <em>FirstViewController</em>, which immediately gets added as a child view controller to the navigation controller. Now let's say we need to present an instance of <em>SecondViewController</em>, using the <em>pushViewController:</em> method. What the navigation controller should do here is add the <em>SecondViewController</em> as a child so we can grab it's view for the animation, add an <em>AnimationViewController</em> as a child, remove the <em>FirstViewController</em>, wait for the animation to complete and finally remove the <em>AnimationViewController</em>.

This seems straightforward but there is one thing we need to take care of. Once the animation starts, the views from the animated controllers are rasterized to textures and no future updates to them will be visible until the animation is done. View layouts (either triggered by autolayout or autoresize masks) are performed on the main thread but asynchronously from view initialization. If we simply grab the view from the <em>SecondViewController</em> as soon as it's instantiated, we might end up with a view that's the wrong size. Instead we can use <em>UIViewController</em>'s <em>transitionFromViewController:toViewController:duration:options:animations:completion:</em> method to get us out of this problem. We can leverage the fact that view layout is done by the time this method's animation block parameter gets called.
<h3>Putting it all together</h3>
Once we have the textures ready, what's left is the fairly standard task of creating an OpenGL scene for the animation. Namely we'll need to create a polygon mesh for a cube (complete with texture coordinates and surface normals for lighting), rotate the cube and call a delegate when the cube has completed 90 degrees of rotation. You can have a look at how this is implemented in the <em>Cube</em> and <em>AnimationViewController</em> classes. GLKit really helps simplify the effort here. It can take care of iOS specific things like setting up a UIView for OpenGL rendering, setting up an animation loop tied to the refresh rate of the device's screen or pausing the animation loop when the app goes into background. You can also use it for out of the box shaders and for linear algebra tasks common in 3D applications.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Physics in a UIKit Based Application]]></title>
    <link href="http://www.codesushi.net/blog/2013/02/physics-uikit-2/"/>
    <updated>2013-02-05T00:00:00+02:00</updated>
    <id>http://www.codesushi.net/blog/2013/02/physics-uikit-2</id>
    <content type="html"><![CDATA[Some of the popular game engines available on iOS like <a title="cocos2d" href="http://www.cocos2d-iphone.org" target="_blank">cocos2d</a> and <a title="Unity" href="http://unity3d.com" target="_blank">Unity</a> come bundled with physics engines so oftentimes the first thought when you want to add a bit of physics to your app is that you need to use one of the fancy game engines you've been hearing so much about. In this post I'll walk you through using the <a title="Box2D" href="http://box2d.org" target="_blank">Box2D</a> physics engine without using any game engine or OpenGL.

Let's start with a simple example. Create a single view iPad application project:

![](http://www.codesushi.net/assets/2013-02-05-physics-uikit-2/images/singleviewapp.png)
![](http://www.codesushi.net/assets/2013-02-05-physics-uikit-2/images/ipadapp.png)

Next we need to setup Box2D. The easiest way to do this is via <a title="CocoaPods" href="http://cocoapods.org" target="_blank">CocoaPods</a>. CocoaPods greatly simplifies library dependency management for iOS and OS X projects. If you haven't used it before you need to run the following commands in the terminal to set it up:
``` bash
$ [sudo] gem install cocoapods
$ pod setup
```
Library dependencies are declared in a text file named Podfile which needs to be placed in the same directory as your xcodeproj file. Create the file and paste in the following:
``` ruby
platform :ios
pod 'box2d', '~> 2.3'
```
This declares you are targeting iOS and want to use the Box2D library using either version 2.3 or any other minor version up to 2.4 but not including 2.4. If you're new to CocoaPods I encourage you to read about the other <a title="dependency declaration options" href="https://github.com/CocoaPods/CocoaPods/wiki/Dependency-declaration-options" target="_blank">dependency declaration options</a> available.

Final step, point your terminal to your Xcode project's folder and run
``` bash
pod install
```
This command will download the Box2D library and in addition create an Xcode workspace that contains your initial project file and a new Pods project where all your dependencies reside. From this point on you should always use the generated workspace instead of the initial project and you'll be good to go.

Let's move on to the good stuff and lay out some core Box2D concepts we'll be using in this tutorial. Box2D simulates interaction between rigid <em>bodies</em>. Bodies have a position and a set of <em>fixtures</em>. Each fixture links a body with a <em>shape</em> and a few physical properties like mass, friction and "bounciness". All bodies are of course part of a <em>world</em> and you could even have multiple worlds if you'd so desire. There are a host of other features available in Box2D that I won't be covering in this tutorial. Have a look over the excellent Box2D <a title="Box2D manual" href="http://box2d.org/manual.pdf" target="_blank">manual</a> to see what else is available.

Now the great part about Box2D is that it's completely display agnostic. Its only job is to keep track of your bodies and ensure that everything interacts realistically. This also means it knows nothing of pixels, points or anything like that. Box2D simulates the "real world" and it's units of measurement are miles, kilograms and seconds. It's up to you to convert UIKit's point based coordinates into something Box2D can handle. There's a catch though: simulating physics on objects of arbitrary size is computationally intensive. To keep things simple Box2D is optimised to handle moving objects of sizes between 0.1 and 10 meters. So considering points and meters equal will not work out very well. Instead we'll use an arbitrary scaling factor to keep bodies within reasonable size.

Let's start by declaring a few functions for converting between points to meters and back:

``` objc
static const CGFloat kPointsToMeterRatio = 32.0;

float32 PointsToMeters(CGFloat points)
{
    return points / kPointsToMeterRatio;
}

CGFloat MetersToPoints(float32 meters)
{
    return meters * kPointsToMeterRatio;
}

b2Vec2 CGPointTob2Vec2(CGPoint point)
{
    float32 x = PointsToMeters(point.x);
    float32 y = PointsToMeters(point.y);
    return b2Vec2(x, y);
}

CGPoint b2Vec2ToCGPoint(b2Vec2 vector)
{
    CGFloat x = MetersToPoints(vector.x);
    CGFloat y = MetersToPoints(vector.y);
    return CGPointMake(x, y);
}
```

I also included here two convenience functions for converting between CGPoints and Box2D vectors and back.

Next, open up ViewController.m and replace its contents with the following:

``` objc
#import "ViewController.h"
#import "World.h"

#import <QuartzCore/QuartzCore.h>

@interface ViewController ()
{
    World *_world;
}

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    _world = [[World alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)];

    [self generateCircles];
}

- (void)generateCircles
{
    CGSize viewSize = self.view.frame.size;
    CGFloat radius = 60;
    srand(time(NULL));
    for(int i = 0;i < 20;i++)
    {
        UIView *circleView = [[UIView alloc] initWithFrame:CGRectMake(rand() % (int)(viewSize.width - radius * 2) + radius,
                                                                      rand() % (int)(viewSize.height - radius * 2) + radius,
                                                                      radius, radius)];
        circleView.backgroundColor = [UIColor redColor];
        circleView.layer.cornerRadius = 30;
        [self.view addSubview:circleView];
        [_world addCircleWithView:circleView];
    }
}

@end
```

The view controller starts by initializing a world object that will handle the interaction with Box2D. The world object is initialized with a frame covering the entire screen. We then create 20 views at random positions on the screen and give them a corner radius to make them look like circles. Finally we pass them to the world object.

Now create a new class called World, do a #import &lt;box2d/Box2D.h&gt; at the top of World.m and add the following ivars to World in the implementation file (which at this point needs to be renamed to World.mm to work with Box2D which is a C++ library):

``` objc
{
    b2World *_world;
    NSMutableArray *_circles;
}
```

Don't worry right now about what these objects represent - I'll talk again about them in the next bits of code. If you never mixed Objective-C and C++ code before, remember that it's always worth isolating C++ code and imports of C++/Objective-C++ files in implementation files. This saves you the trouble of renaming .m files to .mm when you import your mixed language code and keeps your compile time as low as possible since Objective-C code compiles faster than Objective-C++ code.

Moving on, declare an initialization method <em>initWithFrame</em>:

``` objc
- (id)initWithFrame:(CGRect)frame
{
    self = [super init];
    if(self != nil)
    {
        b2Vec2 gravity(0.0f, 10.0f);
        _world = new b2World(gravity);
        _circles = [NSMutableArray array];

        [self createScreenBoundsForFrame:frame];
        [self setupAnimationLoop];
    }

    return self;
}
```

This code will setup a Box2D world object with gravity defined to be pointing upwards on the Y axis - meaning objects will appear to be falling from the top to the bottom of our screen. <em>_circle</em> is an array we'll use to keep track of all the bodies we'll be adding to our world. Next we'll create the invisible borders of our screen in <em>createScreenBoundsForFrame:</em> to keep the views from falling off from the screen and finally setup an animation loop to drive everything in <em>setupAniamtionLoop</em>. Here's the code for <em>createScreenBoundsForFrame</em>:

``` objc
- (void)createScreenBoundsForFrame:(CGRect)frame
{
    b2BodyDef screenBoundsDef;
    screenBoundsDef.position.Set(0.0f, 0.0f);
    b2Body *screenBounds = _world->CreateBody(&screenBoundsDef);

    b2Vec2 worldEdges[5];

    worldEdges[0] = b2Vec2(CGPointTob2Vec2(frame.origin));
    worldEdges[1] = b2Vec2(CGPointTob2Vec2(CGPointMake(CGRectGetMinX(frame), CGRectGetMaxY(frame))));
    worldEdges[2] = b2Vec2(CGPointTob2Vec2(CGPointMake(CGRectGetMaxX(frame), CGRectGetMaxY(frame))));
    worldEdges[3] = b2Vec2(CGPointTob2Vec2(CGPointMake(CGRectGetMaxX(frame), CGRectGetMinY(frame))));
    worldEdges[4] = b2Vec2(CGPointTob2Vec2(frame.origin));

    b2ChainShape worldShape;
    worldShape.CreateChain(worldEdges, 5);
    screenBounds->CreateFixture(&amp;worldShape, 0.0f);
}
```

Here you can see a <em>screenBounds</em> body object being created. Bodies are always instantiated using the Box2D world object that will also keep track and memory manage them. Also notice how the body is created from a body definition object. This allows multiple bodies to be instantiated using the same defining properties. Next we create a chain shape that spans the left, bottom, right and upper edge of the input frame. This is a special type of shape that doesn't have a width and is used mostly for defining boundaries. Finally the shape is bounded to the body using a fixture.

Before looking at the animation loop let's introduce the function that will map UIViews to Box2D bodies:

``` objc
- (void)addCircleWithView:(UIView*)view
{
    NSAssert(view.superview != nil, @"The view parameter is not part of a view hierarchy");

    b2BodyDef bodyDef;
    bodyDef.type = b2_dynamicBody;
    bodyDef.position = CGPointTob2Vec2(view.center);
    b2Body *circle = _world->CreateBody(&bodyDef);

    b2CircleShape shape;
    shape.m_radius = PointsToMeters(view.frame.size.width / 2);

    b2FixtureDef fixtureDef;
    fixtureDef.shape = &shape;
    fixtureDef.density = 1.0f;
    fixtureDef.friction = 0.3f;
    fixtureDef.restitution = 0.8f;

    circle->CreateFixture(&fixtureDef);
    // Associate the body with the passed in view
    circle->SetUserData((__bridge void*)view);

    [_circles addObject:[NSValue valueWithPointer:circle]];
}
```

Here we create a body with the same position as the view, we add it a circle shape that matches the size of the view and a few physical properties. Later on we'll need to know what view each body represents so we save the pointer to the view in the body's user data field.

Let's move on to setting up the animation loop:

``` objc
- (void)setupAnimationLoop
{
    CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(animationLoop:)];
    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
}

- (void)animationLoop:(CADisplayLink*)sender
{
    CFTimeInterval timeDelta = sender.duration * sender.frameInterval;

    int32 velocityIterations = 6;
    int32 positionIterations = 2;

    _world->Step(timeDelta, velocityIterations, positionIterations);

    // Adjust position for all views associated with circle bodies
    for(NSValue *circleWrapper in _circles)
    {
        b2Body *circle = (b2Body*)[circleWrapper pointerValue];
        UIView *view = (__bridge UIView*)circle->GetUserData();
        view.center = b2Vec2ToCGPoint(circle->GetPosition());
    }
}
```

Animations are always computed in discreet time intervals called <em>frames</em>. Animations get more accurate as frames get shorter but since the amount of time required to compute a frame stays relatively constant you take a performance hit when animating in shorter frames. Displays however operate on a fixed frame rate. In the code above, <em>animationLoop:</em> is in charge of animating and drawing a frame on the screen. CADisplayLink is in charge of deciding when the screen is ready to draw something new and will call <em>animationLoop:</em> to do the drawing. It's entirely possible that <em>animationLoop:</em> would require more time to execute than a single screen refresh cycle, but what CADisplayLink ensures is that your animations stay as smooth as possible with the available resources and that no animation frames are being computed if the display is not ready to show them.

Let's look at <em>animationLoop:</em> in more detail. First thing it does is figure out how much time has passed since the last run and passes that info to our world object which will then proceed to update its internal state. There are two extra parameters there: <em>velocityIterations</em> and <em>positionIterations</em>. These have more to do with Box2D's inner workings. What happens is that Box2D approximates body velocity and position in multiple iterations. The more iterations you attempt, the more realistic the outcome. You can fine tune these values until you find something acceptable in terms of performance and realism.

Once Box2D does its thing, all we need to do is iterate over all circle bodies and update the position of their associated UIView to match the bodies' new positions.

Finally, we need to take care of the cleanup. The only C++ object we allocated ourselves is the world object. Everything else was allocated internally by Box2D and will be cleaned up once the world object is destroyed:

``` objc
- (void)dealloc
{
    delete _world;
}
```

That's it! If you followed all the steps you should end up with something like this:
<div class="embed-video-container"><iframe src="http://www.youtube.com/embed/dxox7uz4Sas "></iframe></div>

You can grab the full code for this tutorial from here: <a title="https://github.com/MihaiDamian/Box2DTutorial" href="https://github.com/MihaiDamian/Box2DTutorial" target="_blank">https://github.com/MihaiDamian/Box2DTutorial</a>

So there you have it. Physics engines can be used very easily in a UIKit based app. In fact you could even go and build a game like <a title="Hundreds on iTunes" href="https://itunes.apple.com/us/app/hundreds/id493536432?mt=8" target="_blank">Hundreds</a> using nothing but UIKit and Box2D.
]]></content>
  </entry>
  
</feed>
